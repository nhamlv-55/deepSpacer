from subprocess import PIPE, STDOUT, Popen, run
import json
class SpacerWrapper:

    def __init__(self, z3Path):
        self.spacerProcess = None # Process | None
        self.spacerState = None # "running" | "saturation" | "refutation" | "error" | "timeout" | None

        self.optionsForVisualization = ["fp.spacer.print_json=tmp.json", "fp.spacer.trace_file=spacer.log"]
        self.z3Path = z3Path

    # run Spacer fully automatically on the given input file, and return all the output generated by Spacer
    def start(self, inputFile, userOptions):
        if self.spacerProcess != None:
            self.spacerProcess.kill()

        # note: if an option is supplied twice, Spacer ignores the first occurence
        #       we therefore add the user options first, so that user options conflicting
        #       with visualization options are ignored
        args = [self.z3Path]
        args.extend(userOptions.split())
        args.extend(self.optionsForVisualization)
        args.append(inputFile)

        output = run(args, stdout=PIPE, stderr=STDOUT, universal_newlines=True).stdout

        lines = output.replace('\r\n', '\n').replace('\r', '\n').split('\n')

        with open ("tmp.json", "r") as f:
            graph_json = json.load(f)


        with open("spacer.log", "r") as f:
            progress_trace = f.readlines()

        return lines, graph_json, progress_trace

    # start Spacer with manual clause selection on the given input file, until Spacer asks for a clause to select or finishes execution
    # return the output generated before asking for a clause
    def startManualCS(self, inputFile, userOptions):
        if self.spacerProcess != None:
            self.spacerProcess.kill()

        # note: if an option is supplied twice, Spacer ignores the first occurence
        #       we therefore add the user options first, so that user options conflicting
        #       with visualization options are ignored
        args = [self.z3Path]
        args.extend(userOptions.split())
        args.extend(self.optionsForVisualization)
        args.extend(["--manual_cs", "on", "--time_limit", "0"])
        args.append(inputFile)

        self.spacerProcess = Popen(args, stdin=PIPE, stdout=PIPE, stderr=STDOUT)
        
        newLines = self.collectOutput()
        return newLines

    # perform one clause selection using selectedId
    # return the output generated by that clause selection
    def select(self, selectedId):
        self.spacerProcess.stdin.write(str.encode(str(selectedId) + "\n"))
        self.spacerProcess.stdin.flush()

        newLines = self.collectOutput()
        return newLines

    # helper method
    def collectOutput(self):
        # process lines until a line occurs with either is 1) a commando to enter a number 2) refutation found 3) saturation reached 4) user error
        newLines = []
        line = self.spacerProcess.stdout.readline().decode().rstrip()
        while(True):
            if line.startswith("Pick a clause:"):
                self.spacerState = "running"
                return newLines
            elif line.startswith("% Refutation found. Thanks to"): # TODO: use SZS status instead?
                self.spacerState = "refutation"
                return newLines
            elif line.startswith("% SZS status Satisfiable"):
                self.spacerState = "saturation"
                return newLines
            elif line.startswith("User error: "):
                self.spacerState = "error"
                return newLines
            else:
                newLines.append(line)
                line = self.spacerProcess.stdout.readline().decode().rstrip()


